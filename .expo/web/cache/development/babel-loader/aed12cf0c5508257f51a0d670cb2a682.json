{"ast":null,"code":"var _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  startAsync: true,\n  dismiss: true,\n  getDefaultReturnUrl: true,\n  getRedirectUrl: true,\n  makeRedirectUri: true,\n  loadAsync: true,\n  AuthRequest: true,\n  CodeChallengeMethod: true,\n  Prompt: true,\n  ResponseType: true,\n  fetchDiscoveryAsync: true,\n  resolveDiscoveryAsync: true,\n  generateHexStringAsync: true,\n  useAutoDiscovery: true,\n  useAuthRequest: true,\n  AuthError: true,\n  TokenError: true,\n  TokenResponse: true,\n  AccessTokenRequest: true,\n  RefreshTokenRequest: true,\n  RevokeTokenRequest: true,\n  revokeAsync: true,\n  refreshAsync: true,\n  exchangeCodeAsync: true,\n  fetchUserInfoAsync: true\n};\nexports.startAsync = startAsync;\nexports.dismiss = dismiss;\nexports.getDefaultReturnUrl = getDefaultReturnUrl;\nexports.getRedirectUrl = getRedirectUrl;\nexports.makeRedirectUri = makeRedirectUri;\nexports.loadAsync = loadAsync;\nObject.defineProperty(exports, \"AuthRequest\", {\n  enumerable: true,\n  get: function get() {\n    return _AuthRequest.AuthRequest;\n  }\n});\nObject.defineProperty(exports, \"CodeChallengeMethod\", {\n  enumerable: true,\n  get: function get() {\n    return _AuthRequest2.CodeChallengeMethod;\n  }\n});\nObject.defineProperty(exports, \"Prompt\", {\n  enumerable: true,\n  get: function get() {\n    return _AuthRequest2.Prompt;\n  }\n});\nObject.defineProperty(exports, \"ResponseType\", {\n  enumerable: true,\n  get: function get() {\n    return _AuthRequest2.ResponseType;\n  }\n});\nObject.defineProperty(exports, \"fetchDiscoveryAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _Discovery.fetchDiscoveryAsync;\n  }\n});\nObject.defineProperty(exports, \"resolveDiscoveryAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _Discovery.resolveDiscoveryAsync;\n  }\n});\nObject.defineProperty(exports, \"generateHexStringAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _PKCE.generateHexStringAsync;\n  }\n});\nObject.defineProperty(exports, \"useAutoDiscovery\", {\n  enumerable: true,\n  get: function get() {\n    return _AuthRequestHooks.useAutoDiscovery;\n  }\n});\nObject.defineProperty(exports, \"useAuthRequest\", {\n  enumerable: true,\n  get: function get() {\n    return _AuthRequestHooks.useAuthRequest;\n  }\n});\nObject.defineProperty(exports, \"AuthError\", {\n  enumerable: true,\n  get: function get() {\n    return _Errors.AuthError;\n  }\n});\nObject.defineProperty(exports, \"TokenError\", {\n  enumerable: true,\n  get: function get() {\n    return _Errors.TokenError;\n  }\n});\nObject.defineProperty(exports, \"TokenResponse\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.TokenResponse;\n  }\n});\nObject.defineProperty(exports, \"AccessTokenRequest\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.AccessTokenRequest;\n  }\n});\nObject.defineProperty(exports, \"RefreshTokenRequest\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.RefreshTokenRequest;\n  }\n});\nObject.defineProperty(exports, \"RevokeTokenRequest\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.RevokeTokenRequest;\n  }\n});\nObject.defineProperty(exports, \"revokeAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.revokeAsync;\n  }\n});\nObject.defineProperty(exports, \"refreshAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.refreshAsync;\n  }\n});\nObject.defineProperty(exports, \"exchangeCodeAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.exchangeCodeAsync;\n  }\n});\nObject.defineProperty(exports, \"fetchUserInfoAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.fetchUserInfoAsync;\n  }\n});\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _core = require(\"@unimodules/core\");\n\nvar _expoConstants = _interopRequireWildcard(require(\"expo-constants\"));\n\nvar Linking = _interopRequireWildcard(require(\"expo-linking\"));\n\nvar _expoWebBrowser = require(\"expo-web-browser\");\n\nvar _AuthRequest = require(\"./AuthRequest\");\n\nvar _AuthRequest2 = require(\"./AuthRequest.types\");\n\nvar _Discovery = require(\"./Discovery\");\n\nvar _PKCE = require(\"./PKCE\");\n\nvar _QueryParams = require(\"./QueryParams\");\n\nvar _SessionUrlProvider = require(\"./SessionUrlProvider\");\n\nvar _AuthRequestHooks = require(\"./AuthRequestHooks\");\n\nvar _Errors = require(\"./Errors\");\n\nvar _TokenRequest = require(\"./TokenRequest\");\n\nvar _TokenRequest2 = require(\"./TokenRequest.types\");\n\nObject.keys(_TokenRequest2).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _TokenRequest2[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _TokenRequest2[key];\n    }\n  });\n});\nvar _authLock = false;\nvar sessionUrlProvider = (0, _SessionUrlProvider.getSessionUrlProvider)();\n\nfunction startAsync(options) {\n  var returnUrl, authUrl, startUrl, showInRecents, result, _getQueryParams, params, errorCode;\n\n  return _regenerator.default.async(function startAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          returnUrl = options.returnUrl || sessionUrlProvider.getDefaultReturnUrl();\n          authUrl = options.authUrl;\n          startUrl = sessionUrlProvider.getStartUrl(authUrl, returnUrl);\n          showInRecents = options.showInRecents || false;\n\n          if (authUrl) {\n            _context.next = 6;\n            break;\n          }\n\n          throw new Error('No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.');\n\n        case 6:\n          if (!_authLock) {\n            _context.next = 9;\n            break;\n          }\n\n          if (__DEV__) {\n            console.warn('Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.');\n          }\n\n          return _context.abrupt(\"return\", {\n            type: 'locked'\n          });\n\n        case 9:\n          _authLock = true;\n          _context.prev = 10;\n          _context.next = 13;\n          return _regenerator.default.awrap(_openWebBrowserAsync(startUrl, returnUrl, showInRecents));\n\n        case 13:\n          result = _context.sent;\n\n        case 14:\n          _context.prev = 14;\n          _authLock = false;\n          return _context.finish(14);\n\n        case 17:\n          if (result) {\n            _context.next = 19;\n            break;\n          }\n\n          throw new Error('Unexpected missing AuthSession result');\n\n        case 19:\n          if (result.url) {\n            _context.next = 25;\n            break;\n          }\n\n          if (!result.type) {\n            _context.next = 24;\n            break;\n          }\n\n          return _context.abrupt(\"return\", result);\n\n        case 24:\n          throw new Error('Unexpected AuthSession result with missing type');\n\n        case 25:\n          _getQueryParams = (0, _QueryParams.getQueryParams)(result.url), params = _getQueryParams.params, errorCode = _getQueryParams.errorCode;\n          return _context.abrupt(\"return\", {\n            type: errorCode ? 'error' : 'success',\n            params: params,\n            errorCode: errorCode,\n            authentication: null,\n            url: result.url\n          });\n\n        case 27:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[10,, 14, 17]], Promise);\n}\n\nfunction dismiss() {\n  (0, _expoWebBrowser.dismissAuthSession)();\n}\n\nfunction getDefaultReturnUrl() {\n  return sessionUrlProvider.getDefaultReturnUrl();\n}\n\nfunction getRedirectUrl(path) {\n  return sessionUrlProvider.getRedirectUrl(path);\n}\n\nfunction makeRedirectUri() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      native = _ref.native,\n      path = _ref.path,\n      preferLocalhost = _ref.preferLocalhost,\n      useProxy = _ref.useProxy;\n\n  if (_core.Platform.OS !== 'web') {\n    if (_expoConstants.default.executionEnvironment === _expoConstants.ExecutionEnvironment.Bare) {\n      if (!native) {\n        console.warn(\"makeRedirectUri requires you define a `native` scheme for bare workflow, and standalone native apps, you'll need to manually define it based on your app's URI schemes.\");\n      }\n\n      return native || '';\n    }\n\n    if (_expoConstants.default.executionEnvironment === _expoConstants.ExecutionEnvironment.Standalone && native) {\n      return native;\n    }\n  }\n\n  if (!useProxy || _core.Platform.OS === 'web') {\n    var url = Linking.makeUrl(path);\n\n    if (preferLocalhost) {\n      var ipAddress = url.match(/\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/);\n\n      if (ipAddress != null && ipAddress.length) {\n        var _url$split = url.split(ipAddress[0]),\n            _url$split2 = (0, _slicedToArray2.default)(_url$split, 2),\n            protocol = _url$split2[0],\n            _path = _url$split2[1];\n\n        return protocol + \"localhost\" + _path;\n      }\n    }\n\n    return url;\n  }\n\n  return sessionUrlProvider.getRedirectUrl(path);\n}\n\nfunction loadAsync(config, issuerOrDiscovery) {\n  var request, discovery;\n  return _regenerator.default.async(function loadAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          request = new _AuthRequest.AuthRequest(config);\n          _context2.next = 3;\n          return _regenerator.default.awrap((0, _Discovery.resolveDiscoveryAsync)(issuerOrDiscovery));\n\n        case 3:\n          discovery = _context2.sent;\n          _context2.next = 6;\n          return _regenerator.default.awrap(request.makeAuthUrlAsync(discovery));\n\n        case 6:\n          return _context2.abrupt(\"return\", request);\n\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _openWebBrowserAsync(startUrl, returnUrl, showInRecents) {\n  var result;\n  return _regenerator.default.async(function _openWebBrowserAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return _regenerator.default.awrap((0, _expoWebBrowser.openAuthSessionAsync)(startUrl, returnUrl, {\n            showInRecents: showInRecents\n          }));\n\n        case 2:\n          result = _context3.sent;\n\n          if (!(result.type === 'cancel' || result.type === 'dismiss')) {\n            _context3.next = 5;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            type: result.type\n          });\n\n        case 5:\n          return _context3.abrupt(\"return\", result);\n\n        case 6:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"sources":["../src/AuthSession.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform } from '@unimodules/core';\nimport Constants, { ExecutionEnvironment } from 'expo-constants';\nimport * as Linking from 'expo-linking';\nimport { dismissAuthSession, openAuthSessionAsync } from 'expo-web-browser';\n\nimport { AuthRequest } from './AuthRequest';\nimport {\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  Prompt,\n  ResponseType,\n} from './AuthRequest.types';\nimport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n} from './AuthSession.types';\nimport {\n  DiscoveryDocument,\n  fetchDiscoveryAsync,\n  Issuer,\n  IssuerOrDiscovery,\n  ProviderMetadata,\n  resolveDiscoveryAsync,\n} from './Discovery';\nimport { generateHexStringAsync } from './PKCE';\nimport { getQueryParams } from './QueryParams';\nimport { getSessionUrlProvider } from './SessionUrlProvider';\n\nlet _authLock = false;\nconst sessionUrlProvider = getSessionUrlProvider();\n\nexport async function startAsync(options: AuthSessionOptions): Promise<AuthSessionResult> {\n  const returnUrl = options.returnUrl || sessionUrlProvider.getDefaultReturnUrl();\n  const authUrl = options.authUrl;\n  const startUrl = sessionUrlProvider.getStartUrl(authUrl, returnUrl);\n  const showInRecents = options.showInRecents || false;\n\n  // Prevent accidentally starting to an empty url\n  if (!authUrl) {\n    throw new Error(\n      'No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.'\n    );\n  }\n\n  // Prevent multiple sessions from running at the same time, WebBrowser doesn't\n  // support it this makes the behavior predictable.\n  if (_authLock) {\n    if (__DEV__) {\n      console.warn(\n        'Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.'\n      );\n    }\n\n    return { type: 'locked' };\n  }\n\n  // About to start session, set lock\n  _authLock = true;\n\n  let result;\n  try {\n    result = await _openWebBrowserAsync(startUrl, returnUrl, showInRecents);\n  } finally {\n    // WebBrowser session complete, unset lock\n    _authLock = false;\n  }\n\n  // Handle failures\n  if (!result) {\n    throw new Error('Unexpected missing AuthSession result');\n  }\n  if (!result.url) {\n    if (result.type) {\n      return result;\n    } else {\n      throw new Error('Unexpected AuthSession result with missing type');\n    }\n  }\n\n  const { params, errorCode } = getQueryParams(result.url);\n\n  return {\n    type: errorCode ? 'error' : 'success',\n    params,\n    errorCode,\n    authentication: null,\n    url: result.url,\n  };\n}\n\nexport function dismiss() {\n  dismissAuthSession();\n}\n\nexport function getDefaultReturnUrl(): string {\n  return sessionUrlProvider.getDefaultReturnUrl();\n}\n\n/**\n * @deprecated Use `makeRedirectUri({ path, useProxy })` instead.\n *\n * @param path\n */\nexport function getRedirectUrl(path?: string): string {\n  return sessionUrlProvider.getRedirectUrl(path);\n}\n\n/**\n * Create a redirect url for the current platform.\n * - **Web:** Generates a path based on the current \\`window.location\\`. For production web apps you should hard code the URL.\n * - **Managed, and Custom workflow:** Uses the `scheme` property of your `app.config.js` or `app.json`.\n *   - **Proxy:** Uses auth.expo.io as the base URL for the path. This only works in Expo client and standalone environments.\n * - **Bare workflow:** Will fallback to using the `native` option for bare workflow React Native apps.\n *\n * @param options Additional options for configuring the path.\n */\nexport function makeRedirectUri({\n  native,\n  path,\n  preferLocalhost,\n  useProxy,\n}: AuthSessionRedirectUriOptions = {}): string {\n  if (Platform.OS !== 'web') {\n    // Bare workflow\n    if (Constants.executionEnvironment === ExecutionEnvironment.Bare) {\n      if (!native) {\n        // TODO(Bacon): Link to docs or fyi\n        console.warn(\n          \"makeRedirectUri requires you define a `native` scheme for bare workflow, and standalone native apps, you'll need to manually define it based on your app's URI schemes.\"\n        );\n      }\n      // Returning an empty string makes types easier to work with.\n      // Server will throw an error about the invalid URI scheme.\n      return native || '';\n    }\n    // Should use the user-defined native scheme in standalone builds\n    if (Constants.executionEnvironment === ExecutionEnvironment.Standalone && native) {\n      return native;\n    }\n  }\n  if (!useProxy || Platform.OS === 'web') {\n    const url = Linking.makeUrl(path);\n\n    if (preferLocalhost) {\n      const ipAddress = url.match(\n        /\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/\n      );\n      // Only replace if an IP address exists\n      if (ipAddress?.length) {\n        const [protocol, path] = url.split(ipAddress[0]);\n        return `${protocol}localhost${path}`;\n      }\n    }\n\n    return url;\n  }\n  // Attempt to use the proxy\n  return sessionUrlProvider.getRedirectUrl(path);\n}\n\n/**\n * Build an `AuthRequest` and load it before returning.\n *\n * @param config\n * @param issuerOrDiscovery\n */\nexport async function loadAsync(\n  config: AuthRequestConfig,\n  issuerOrDiscovery: IssuerOrDiscovery\n): Promise<AuthRequest> {\n  const request = new AuthRequest(config);\n  const discovery = await resolveDiscoveryAsync(issuerOrDiscovery);\n  await request.makeAuthUrlAsync(discovery);\n  return request;\n}\n\nasync function _openWebBrowserAsync(startUrl: string, returnUrl: string, showInRecents: boolean) {\n  // $FlowIssue: Flow thinks the awaited result can be a promise\n  const result = await openAuthSessionAsync(startUrl, returnUrl, { showInRecents });\n  if (result.type === 'cancel' || result.type === 'dismiss') {\n    return { type: result.type };\n  }\n\n  return result;\n}\n\nexport { useAutoDiscovery, useAuthRequest } from './AuthRequestHooks';\nexport { AuthError, TokenError } from './Errors';\n\nexport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n  AuthRequest,\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  DiscoveryDocument,\n  Issuer,\n  IssuerOrDiscovery,\n  Prompt,\n  ProviderMetadata,\n  ResponseType,\n  resolveDiscoveryAsync,\n  fetchDiscoveryAsync,\n  generateHexStringAsync,\n};\n\nexport {\n  // Token classes\n  TokenResponse,\n  AccessTokenRequest,\n  RefreshTokenRequest,\n  RevokeTokenRequest,\n  // Token methods\n  revokeAsync,\n  refreshAsync,\n  exchangeCodeAsync,\n  fetchUserInfoAsync,\n} from './TokenRequest';\n\n// Token types\nexport * from './TokenRequest.types';\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}
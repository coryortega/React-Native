{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useAutoDiscovery = useAutoDiscovery;\nexports.useLoadedAuthRequest = useLoadedAuthRequest;\nexports.useAuthRequestResult = useAuthRequestResult;\nexports.useAuthRequest = useAuthRequest;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _react = require(\"react\");\n\nvar _AuthRequest = require(\"./AuthRequest\");\n\nvar _Discovery = require(\"./Discovery\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction useAutoDiscovery(issuerOrDiscovery) {\n  var _useState = (0, _react.useState)(null),\n      _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n      discovery = _useState2[0],\n      setDiscovery = _useState2[1];\n\n  (0, _react.useEffect)(function () {\n    (0, _Discovery.resolveDiscoveryAsync)(issuerOrDiscovery).then(function (discovery) {\n      setDiscovery(discovery);\n    });\n  }, [issuerOrDiscovery]);\n  return discovery;\n}\n\nfunction useLoadedAuthRequest(config, discovery, AuthRequestInstance) {\n  var _useState3 = (0, _react.useState)(null),\n      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),\n      request = _useState4[0],\n      setRequest = _useState4[1];\n\n  var scopeString = (0, _react.useMemo)(function () {\n    var _config$scopes;\n\n    return (_config$scopes = config.scopes) == null ? void 0 : _config$scopes.join(',');\n  }, [config.scopes]);\n  var extraParamsString = (0, _react.useMemo)(function () {\n    return JSON.stringify(config.extraParams || {});\n  }, [config.extraParams]);\n  (0, _react.useEffect)(function () {\n    var isMounted = true;\n\n    if (discovery) {\n      var _request = new AuthRequestInstance(config);\n\n      _request.makeAuthUrlAsync(discovery).then(function () {\n        if (isMounted) {\n          setRequest(_request);\n        }\n      });\n    }\n\n    return function () {\n      isMounted = false;\n    };\n  }, [discovery == null ? void 0 : discovery.authorizationEndpoint, config.clientId, config.redirectUri, config.responseType, config.prompt, config.clientSecret, config.codeChallenge, config.state, config.usePKCE, scopeString, extraParamsString]);\n  return request;\n}\n\nfunction useAuthRequestResult(request, discovery) {\n  var customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _useState5 = (0, _react.useState)(null),\n      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),\n      result = _useState6[0],\n      setResult = _useState6[1];\n\n  var promptAsync = (0, _react.useCallback)(function _callee() {\n    var _customOptions$window;\n\n    var _ref,\n        _ref$windowFeatures,\n        windowFeatures,\n        options,\n        inputOptions,\n        result,\n        _args = arguments;\n\n    return _regenerator.default.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, _ref$windowFeatures = _ref.windowFeatures, windowFeatures = _ref$windowFeatures === void 0 ? {} : _ref$windowFeatures, options = (0, _objectWithoutProperties2.default)(_ref, [\"windowFeatures\"]);\n\n            if (!(!discovery || !request)) {\n              _context.next = 3;\n              break;\n            }\n\n            throw new Error('Cannot prompt to authenticate until the request has finished loading.');\n\n          case 3:\n            inputOptions = _objectSpread(_objectSpread(_objectSpread({}, customOptions), options), {}, {\n              windowFeatures: _objectSpread(_objectSpread({}, (_customOptions$window = customOptions.windowFeatures) != null ? _customOptions$window : {}), windowFeatures)\n            });\n            _context.next = 6;\n            return _regenerator.default.awrap(request == null ? void 0 : request.promptAsync(discovery, inputOptions));\n\n          case 6:\n            result = _context.sent;\n            setResult(result);\n            return _context.abrupt(\"return\", result);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }, [request == null ? void 0 : request.url, discovery == null ? void 0 : discovery.authorizationEndpoint]);\n  return [result, promptAsync];\n}\n\nfunction useAuthRequest(config, discovery) {\n  var request = useLoadedAuthRequest(config, discovery, _AuthRequest.AuthRequest);\n\n  var _useAuthRequestResult = useAuthRequestResult(request, discovery),\n      _useAuthRequestResult2 = (0, _slicedToArray2.default)(_useAuthRequestResult, 2),\n      result = _useAuthRequestResult2[0],\n      promptAsync = _useAuthRequestResult2[1];\n\n  return [request, result, promptAsync];\n}","map":{"version":3,"sources":["../src/AuthRequestHooks.ts"],"names":[],"mappings":"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","sourcesContent":["import { useCallback, useMemo, useEffect, useState } from 'react';\n\nimport { AuthRequest } from './AuthRequest';\nimport { AuthRequestConfig, AuthRequestPromptOptions } from './AuthRequest.types';\nimport { AuthSessionResult } from './AuthSession.types';\nimport { DiscoveryDocument, IssuerOrDiscovery, resolveDiscoveryAsync } from './Discovery';\n\n/**\n * Fetch the discovery document from an OpenID Connect issuer.\n *\n * @param issuerOrDiscovery\n */\nexport function useAutoDiscovery(issuerOrDiscovery: IssuerOrDiscovery): DiscoveryDocument | null {\n  const [discovery, setDiscovery] = useState<DiscoveryDocument | null>(null);\n\n  useEffect(() => {\n    resolveDiscoveryAsync(issuerOrDiscovery).then(discovery => {\n      setDiscovery(discovery);\n    });\n  }, [issuerOrDiscovery]);\n\n  return discovery;\n}\n\nexport function useLoadedAuthRequest(\n  config: AuthRequestConfig,\n  discovery: DiscoveryDocument | null,\n  AuthRequestInstance: typeof AuthRequest\n): AuthRequest | null {\n  const [request, setRequest] = useState<AuthRequest | null>(null);\n  const scopeString = useMemo(() => config.scopes?.join(','), [config.scopes]);\n  const extraParamsString = useMemo(() => JSON.stringify(config.extraParams || {}), [\n    config.extraParams,\n  ]);\n  useEffect(\n    () => {\n      let isMounted = true;\n\n      if (discovery) {\n        const request = new AuthRequestInstance(config);\n        request.makeAuthUrlAsync(discovery).then(() => {\n          if (isMounted) {\n            // @ts-ignore\n            setRequest(request);\n          }\n        });\n      }\n      return () => {\n        isMounted = false;\n      };\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      discovery?.authorizationEndpoint,\n      config.clientId,\n      config.redirectUri,\n      config.responseType,\n      config.prompt,\n      config.clientSecret,\n      config.codeChallenge,\n      config.state,\n      config.usePKCE,\n      scopeString,\n      extraParamsString,\n    ]\n  );\n  return request;\n}\n\ntype PromptMethod = (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>;\n\nexport function useAuthRequestResult(\n  request: AuthRequest | null,\n  discovery: DiscoveryDocument | null,\n  customOptions: AuthRequestPromptOptions = {}\n): [AuthSessionResult | null, PromptMethod] {\n  const [result, setResult] = useState<AuthSessionResult | null>(null);\n\n  const promptAsync = useCallback(\n    async ({ windowFeatures = {}, ...options }: AuthRequestPromptOptions = {}) => {\n      if (!discovery || !request) {\n        throw new Error('Cannot prompt to authenticate until the request has finished loading.');\n      }\n      const inputOptions = {\n        ...customOptions,\n        ...options,\n        windowFeatures: {\n          ...(customOptions.windowFeatures ?? {}),\n          ...windowFeatures,\n        },\n      };\n      const result = await request?.promptAsync(discovery, inputOptions);\n      setResult(result);\n      return result;\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [request?.url, discovery?.authorizationEndpoint]\n  );\n\n  return [result, promptAsync];\n}\n\n/**\n * Load an authorization request.\n * Returns a loaded request, a response, and a prompt method.\n * When the prompt method completes then the response will be fulfilled.\n *\n * @param config\n * @param discovery\n */\nexport function useAuthRequest(\n  config: AuthRequestConfig,\n  discovery: DiscoveryDocument | null\n): [\n  AuthRequest | null,\n  AuthSessionResult | null,\n  (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>\n] {\n  const request = useLoadedAuthRequest(config, discovery, AuthRequest);\n  const [result, promptAsync] = useAuthRequestResult(request, discovery);\n  return [request, result, promptAsync];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}